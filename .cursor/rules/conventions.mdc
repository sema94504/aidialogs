---
alwaysApply: false
---
Ты разрабатываешь Telegram бота по @docs/vision.md.

Следуй принципам KISS, MVP, линейность. Максимальная простота, только необходимый функционал, прямые зависимости.

## Стиль кода

Пиши код:
- 1 класс = 1 файл, строго
- Без паттернов и абстракций, только если есть реальная необходимость
- Используй типизацию везде: `list[dict]`, `dict[int, list]`
- Не добавляй docstrings, код должен быть самодокументируемым
- Конкретные реализации, не обобщения

## Форматирование

- Длина строки: 100 символов
- Используй Ruff для форматирования и линтинга
- Перед коммитом: `make format && make lint`
- Следуй PEP 8 с настройками Ruff

## Типизация

- Python 3.11+ синтаксис: `list[dict]`, `dict[int, str]`
- Type hints для всех функций и методов
- Без `Any` где возможно
- Проверка через mypy (если доступен)

## Именование

- Классы: `PascalCase` (Config, TelegramBot)
- Функции/методы: `snake_case` (_start_handler, get_response)
- Константы: `UPPER_SNAKE_CASE` (если используются)
- Приватные методы: `_private_method`

## Структура проекта

```
src/main.py          # точка входа
src/config.py        # Config класс
src/bot.py           # TelegramBot класс
src/llm_client.py    # LLMClient класс
src/session_manager.py # SessionManager (после рефакторинга)
```
Поток: main.py -> Config -> Bot -> LLMClient

## Данные

Только в памяти:
- `user_sessions: dict[int, list[dict]]` управляется SessionManager
- Никаких БД для MVP
- История теряется при рестарте

## Технологии

- Python 3.11+, uv (не pip/poetry)
- aiogram 3.x (polling), openai, pytest
- Ruff (линтер + форматтер)
- pytest-cov (покрытие тестами)
- mypy (проверка типов)

## Логирование

Встроенный `logging` в консоль + bot.log.
Логируй: старт/стоп, входящие сообщения, вызовы LLM, ошибки.

```python
logger = logging.getLogger(__name__)
logger.info("Информационное сообщение")
logger.error(f"Ошибка: {e}")
```

## Тестирование

Стандарты:
- Покрытие >80% для критичного кода
- Используй моки для внешних зависимостей
- Тестируй edge cases и error handling
- Один тест = одна проверка

Структура теста:
```python
def test_feature():
    # Arrange
    setup_data()
    
    # Act
    result = function_to_test()
    
    # Assert
    assert result == expected
```

Что тестируем:
- Config - валидация
- LLMClient - формирование запросов
- Bot - обработка команд и сообщений
- SessionManager - управление сессиями
- Error handling

Что НЕ тестируем:
- Реальные API вызовы
- E2E сценарии (пока)

## Обработка ошибок

- Всегда логируй ошибки с контекстом
- Используй try/except только где необходимо
- Не глотай исключения молча
- Возвращай понятные сообщения пользователю

```python
try:
    result = risky_operation()
except Exception as e:
    logger.error(f"Ошибка операции для {user_id}: {e}")
    await message.answer("Извините, произошла ошибка")
```

## Лучшие практики Python

1. **SOLID принципы:**
   - SRP: один класс = одна ответственность
   - DIP: зависимость от абстракций (Protocol для интерфейсов)

2. **DRY:**
   - Не дублируй код
   - Используй функции для повторяющейся логики

3. **KISS:**
   - Простота превыше всего
   - Не усложняй без необходимости

4. **Явное лучше неявного:**
   - Явные импорты (не `from module import *`)
   - Явные типы
   - Явная обработка ошибок

## Инструменты качества

Перед коммитом выполни:
```bash
make format     # Форматирование
make lint       # Проверка стиля
make typecheck  # Проверка типов (если mypy добавлен)
make test       # Тесты
make coverage   # Покрытие
```

## Конфигурация

Только через `.env`, никаких yaml/json/toml для конфига.
